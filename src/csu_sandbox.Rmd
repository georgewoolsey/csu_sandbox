---
title: "Sandbox"
author: "George Woolsey"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
editor_options: 
  chunk_output_type: console
knit: (function(inputFile, encoding){ 
    out_dir <- '../';
    rmarkdown::render(inputFile, encoding = encoding, output_file=file.path(dirname(inputFile), out_dir, 'index.html'));
  })
---

# Caution

This is a sandbox. Do not trust or re-use anything on here because it is a sandbox.

# Data

The data utilized for this analysis was generated in Google Earth Engine using [this script](https://code.earthengine.google.com/62b842b73336f00cc68e347ac306ca2a?noload=true). This program outputs 1) a data table of features - USDA Forest Service (USFS) managed forests - with user-defined constraints to forest managment and the reduction in treatable forested area based on those constraints, and 2) a shapefile of the spatial arrangement of treatable and constrained forested area within the boundary of each feature.

The data products used in this study include:

1) The [National Land Cover Database (NLCD)](https://www.usgs.gov/centers/eros/science/national-land-cover-database) was used to define forested area based on 2019 classification at 30m.
2) The [PAD-US](https://www.usgs.gov/programs/gap-analysis-project/science/pad-us-data-overview) product was used to identify protected areas that are dedicated to the preservation of biological diversity and to other natural, recreation and cultural uses, managed for these purposes through legal or other effective means.
3) The [USGS 3DEP](https://www.usgs.gov/3d-elevation-program/about-3dep-products-services) Seamless National Map (10m) was used to determine slope.
4) The [USFWS Threatened & Endangered Species Active Critical Habitat Report](https://ecos.fws.gov/ecp/report/table/critical-habitat.html) was used to determin the proposed and final critical habitat for species listed as Threatened and Endangered by the FWS, or that are jointly managed by FWS/NMFS.
5) The [National Hydrography Dataset (NHD)](https://www.usgs.gov/national-hydrography/national-hydrography-dataset) was used to define the United States water drainage network made up of stream features and waterbody polygons.
6) Road and Trail networks were determined utilizing:
    i.  The United States Census Bureau [TIGER dataset](https://www.census.gov/programs-surveys/geography/guidance/tiger-data-products-guide.html) (2016 release)
    ii. The [USFS FACTS database](https://data.fs.usda.gov/geodata/edw/datasets.php?xmlKeyword) products: [Motor Vehicle Use Map: Roads](https://data.fs.usda.gov/geodata/edw/edw_resources/meta/S_USA.Road_MVUM.xml); [Motor Vehicle Use Map: Trails](https://data.fs.usda.gov/geodata/edw/edw_resources/meta/S_USA.Trail_MVUM.xml); [National Forest System Roads](https://data.fs.usda.gov/geodata/edw/edw_resources/meta/S_USA.RoadCore_FS.xml); [National Forest System Trails](https://data.fs.usda.gov/geodata/edw/edw_resources/meta/S_USA.TrailNFS_Publish.xml)

# Treatable Area Definition

Constraint levels from least flexible to most flexible in interpretation and implementation:

0) Forested - forested area based on NLCD (2019) classification at 30m
1) Protected - GAP Status 1 and inventoried roadless areas (IRA)
2) Slope > 35% - based on DEM at 10m
3) Administrative - USFWS sensitive species habitat...*need to add GAP Status 2*
4) Riparian Buffer - buffer of 100 ft. on streams and waterbodies based on NHD water network
5) Distance from Road > 2000ft - based on road and trail data layers

# Setup

```{r, include=FALSE, warning=F, message=F}
# knit options
knitr::opts_chunk$set(
  echo = TRUE
  , warning = FALSE
  , message = FALSE
  # , results='hide'
  , fig.width = 10
  , fig.height = 7
)
```

```{r}
# bread-and-butter
library(tidyverse)
library(lubridate)
library(viridis)
library(scales)
library(latex2exp)
# visualization
library(kableExtra)
library(cowplot)
library(mapview) #Interactive maps
library(leafpop) #map html popup
# spatial analysis
library(sf)
library(USAboundaries)
library(dismo)
# set seed
set.seed(11)
```

# Load Data

```{r data-read}
# data table
# read multiple files
constrained_wide <- 
  list.files("../data/")[grep("forestmgmtconstraint_statistics",list.files("../data/"))] |> 
    purrr::map(function(x){read.csv(paste0("../data/",x))}) |> 
    dplyr::bind_rows() |> 
      dplyr::rename_with(tolower) |> 
      dplyr::rename_with(make.names) |> 
      dplyr::rename(feature_id = system.index) |> 
      dplyr::mutate(
        forest_shortname = commonname |>  
          stringr::str_replace_all(c("National Forests"="", "National Forest"="")) |>  
          trimws()
        , region = paste0("Region ",as.numeric(region))
      ) |> 
      dplyr::mutate(across(
        tidyselect::ends_with("_m2")
        , ~ as.numeric(.x) / 10000
      )) |> 
      dplyr::rename_with(
        ~ gsub("_m2", "_ha", .x)
        , tidyselect::ends_with("_m2")
      ) |> 
      dplyr::mutate(across(
        tidyselect::starts_with("pct_")
        , ~ as.numeric(.)
      )) |> 
      dplyr::mutate(
        pct_rdctn1_protected = -1*(1 - pct_rmn1_protected)
        , pct_rdctn2_slope = -1*(pct_rmn1_protected - pct_rmn2_slope)
        , pct_rdctn3_administrative = -1*(pct_rmn2_slope - pct_rmn3_administrative)
        , pct_rdctn4_riparian = -1*(pct_rmn3_administrative - pct_rmn4_riparian)
        , pct_rdctn5_roads = -1*(pct_rmn4_riparian - pct_rmn5_roads)
        , pct_rdctn_total = -1*(1 - pct_rmn5_roads)
      )
# spatial
constrained_spatial <- 
  list.files("../data/",pattern = "\\.shp$")[
    grep("forestmgmtconstraint_vectors",list.files("../data/",pattern = "\\.shp$"))
  ] |> 
    purrr::map(function(x){sf::read_sf(paste0("../data/",x))}) |> 
    dplyr::bind_rows() |> 
    dplyr::left_join(
      constrained_wide |> dplyr::select(feature_id, forest_shortname, commonname, region)
      , by = join_by(feature_id)
    ) |> 
    dplyr::mutate(
      IsTreatable = factor(
        istreatabl
        , ordered = TRUE
        , levels = c(0,1)
        , labels = c("Constrained", "Treatable")
      )
    ) |> 
    dplyr::rename(Forest=commonname)
    
```

# Reduction Treatable Area Table

```{r est-table, results='asis'}
tbl_temp <- constrained_wide |> 
  dplyr::mutate(across(
    tidyselect::ends_with("_ha")
    , ~ scales::comma(.x, accuracy = 1)
  )) |>
  dplyr::mutate(across(
    tidyselect::starts_with("pct_")
    , ~ scales::percent(.x, accuracy = 0.1)
  )) |> 
  dplyr::select(
    region
    , forest_shortname
    , covertype_area_ha
    , pct_rdctn1_protected
    , pct_rdctn2_slope
    , pct_rdctn3_administrative
    , pct_rdctn4_riparian
    , pct_rdctn5_roads
    , rmn5_roads_area_ha
    , pct_rmn5_roads
  ) |> 
  dplyr::arrange(region,forest_shortname)
# make table
kableExtra::kable(
    tbl_temp |> dplyr::select(-c(region))
    , caption = "Forested area of each National Forest<br>percent reduction of different types of constraints on mechanical treatment"
    , col.names = c(
      ""
      , "Forested (ha)"
      , "Protected"
      , "Slope>35%"
      , "Administrative"
      , "Riparian Buffer (100ft)"
      , "Roads>2000ft"
      , "Remaining (ha)"
      , "Remaining (%)"
    )
  ) |>  
  add_header_above(c(" " = 1, "Constraint\nLeast Flexible to Most Flexible" = 6, " " = 2)) |>
  kable_classic("striped", full_width=T) |> 
  pack_rows(index = table(forcats::fct_inorder(tbl_temp$region))) |> 
  kableExtra::kable_styling(font_size = 11) |>  
  kableExtra::scroll_box(width = "740px")
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

# Remaining Treatable Forest Plot

```{r plt-rmn, fig.height=12}
ggplot(data = constrained_wide, mapping = aes(x = pct_rmn5_roads, y = reorder(forest_shortname, -pct_rmn5_roads), fill = region)) +
  geom_col(color = NA, width = 0.7) +
  geom_text(
    mapping = aes(label = scales::percent(pct_rmn5_roads, accuracy = 1))
    , color = "black", size = 3
    , hjust = -0.1
  ) +
  facet_grid(rows = vars(region), scales = "free_y") + 
  scale_fill_viridis_d(alpha = 0.8) +
  scale_x_continuous(expand = expansion(mult = c(0, .1)),labels = scales::percent_format()) +
  labs(
    fill = ""
    , y = ""
    , x = "Treatable Forested Area Remaining (%)"
  ) +
  theme_light() +
  theme(
    legend.position = "none" # c(0.9, 0.9)
    , legend.title = element_text(size=7)
    , axis.title = element_text(size=9)
    , axis.text.x = element_text(size=7)
  )
```

# Constraint Reductions Plot

```{r plt-rdctn-cnstrt, fig.height=12}
# reshape
constrained_pct_rdctn_long <- constrained_wide |>
  dplyr::select(region, forest_shortname, tidyselect::starts_with("pct_rdctn")) |> 
  tidyr::pivot_longer(
    cols = tidyselect::starts_with("pct_rdctn")
    , names_to = "constraint"
    , values_to = "pct_rdctn"
    , names_prefix = "pct_rdctn"
    , values_drop_na = F
  ) |> 
  tidyr::separate_wider_delim(constraint, "_", names = c("constraint_lvl", "constraint")) |> 
  dplyr::mutate(
    constraint_lvl = as.numeric(constraint_lvl)
    , constraint = factor(
        constraint
        , ordered = TRUE
        , levels = c(
          "protected"
          , "slope"
          , "administrative"
          , "riparian"
          , "roads"
          , "total"       
        )
        , labels = c(
          "Protected"
          , "Slope>35%"
          , "Administrative"
          , "Riparian Buffer (100ft)"
          , "Roads>2000ft"
          , "Total"
        )
      ) |> forcats::fct_rev()
  ) |> 
  dplyr::left_join(
    constrained_wide |> dplyr::select(region,forest_shortname,pct_rdctn_total)
    , by = join_by(region,forest_shortname)
  )
# plot
ggplot() +
  geom_col(
    data = constrained_pct_rdctn_long |> dplyr::filter(constraint!="Total")
    , mapping = aes(y = reorder(forest_shortname,-pct_rdctn_total), x = pct_rdctn, fill = constraint)
    , color = NA, width = 0.7
  ) +
  geom_text(
    data = constrained_pct_rdctn_long |> dplyr::filter(constraint=="Total")
    , mapping = aes(
      y = reorder(forest_shortname,-pct_rdctn_total), x = pct_rdctn_total
      , label = scales::percent(pct_rdctn_total, accuracy = 1)
    )
    , color = "black", size = 3
    , hjust = -0.1
  ) +
  facet_grid(rows = vars(region), scales = "free_y") + 
  scale_fill_viridis_d(option = "plasma", alpha = 0.8) +
  scale_x_reverse(expand = expansion(mult = c(0, .1)),labels = scales::percent_format()) +
  labs(
    fill = ""
    , y = ""
    , x = "Constraint Reduction in Treatable Forested Area (%)"
  ) +
  theme_light() +
  theme(
    legend.position = "top"
    , legend.direction  = "horizontal"
    , legend.title = element_text(size=7)
    , axis.title = element_text(size=9)
    , axis.text.x = element_text(size=7)
  )
```

# Reduction Treatable Area Plot

```{r plt-rdctn, results='hide'}
# reshape
constrained_pct_rmn_long <- constrained_wide |>
  dplyr::mutate(pct_rmn_forested=1) |> 
  dplyr::select(region, forest_shortname, tidyselect::starts_with("pct_rmn")) |> 
  tidyr::pivot_longer(
    cols = tidyselect::starts_with("pct_rmn")
    , names_to = "constraint"
    , values_to = "pct_rmn"
    , names_prefix = "pct_rmn"
    , values_drop_na = F
  ) |> 
  tidyr::separate_wider_delim(constraint, "_", names = c("constraint_lvl", "constraint")) |> 
  dplyr::mutate(
    constraint = factor(
        constraint
        , ordered = TRUE
        , levels = c(
          "forested"
          , "protected"
          , "slope"
          , "administrative"
          , "riparian"
          , "roads"       
        )
        , labels = c(
          "Forested"
          , "Protected"
          , "Slope>35%"
          , "Administrative"
          , "Riparian Buffer (100ft)"
          , "Roads>2000ft"
        )
      )
  ) |> 
  dplyr::arrange(region, forest_shortname, constraint)

# plot
plt_lines_fn <- function(rgn) {
  (
  ggplot(data = constrained_pct_rmn_long |> dplyr::filter(region==rgn)
         , mapping = aes(x = constraint, y = pct_rmn, group = forest_shortname)
    ) +
    geom_line(mapping=aes(color = forest_shortname), linewidth = 1.5) +
    geom_label(
      mapping=aes(label = scales::percent(pct_rmn, scale = 100, accuracy = 1))
      , color = "black"
      , size = 3
      , label.padding = unit(0.15, "lines")
    ) +
    scale_color_viridis_d(option = "turbo", alpha = 0.8) +
    scale_y_continuous(labels = scales::percent_format()) +
    scale_x_discrete(labels = scales::label_wrap(10)) +
    labs(
      x = "Constraint\nLeast Flexible \U2192 Most Flexible"
      , y = "Forested Area Remaining"
      , subtitle = rgn
    ) +
    theme_bw() +
    theme(
      legend.position = "top"
      , legend.title = element_blank()
      , legend.text = element_text(size = 7)
    ) +
    guides(
      color = guide_legend(nrow=3,byrow=TRUE,override.aes=list(size = 5))
    )
  )
}
constrained_pct_rmn_long |> dplyr::pull(region) |> unique() |> 
  purrr::map(plt_lines_fn)
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

# Map of Treatable/Constrained

Example for the Bighorn National Forest

```{r mapview, results='asis'}
# filter shapes
if(FALSE){
filter_temp <- constrained_spatial |> 
  dplyr::filter(
    region == "Region 2"
  ) |> 
  dplyr::mutate(
    longitude = sf::st_coordinates(sf::st_centroid(geometry))[,1]
    , latitude = sf::st_coordinates(sf::st_centroid(geometry))[,2]
  ) |> 
  sf::st_drop_geometry() |> 
  dplyr::group_by(region, forest_shortname, feature_id) |> 
  dplyr::summarise(
    longitude = mean(longitude, na.rm = T)
    , latitude = mean(latitude, na.rm = T)
  ) |> 
  dplyr::ungroup() |> 
  sf::st_as_sf(coords = c("longitude", "latitude"), crs = sf::st_crs(constrained_spatial)) |> 
  sf::st_intersection(
    USAboundaries::us_states(states = c("CO")) |> 
      sf::st_transform(crs= sf::st_crs(constrained_spatial))
  ) |> 
  sf::st_drop_geometry() |> 
  dplyr::select(region, forest_shortname, feature_id) |> 
  dplyr::slice_sample(n = 1)
}
# filter
constrained_spatial_temp <- constrained_spatial |> 
  dplyr::filter(forest_shortname == "Bighorn") |> 
  dplyr::group_by(Forest,IsTreatable) |> 
  dplyr::summarise(
    geometry = sf::st_union(geometry)
  ) |> 
  dplyr::ungroup()
  # dplyr::inner_join(
  #   filter_temp
  #   , by = dplyr::join_by(region, forest_shortname, feature_id)
  # )
# basemap option
mapview::mapviewOptions(homebutton = FALSE, basemaps = c("Esri.WorldImagery"))
# map
mapview::mapview( constrained_spatial_temp
        , zcol = "IsTreatable"
        , col.regions = viridis::turbo(n=2,direction = -1)
        , alpha.regions = 0.6
        , lwd = 0
        , label = FALSE
        , legend = FALSE
        , layer.name = "Treatable-Constrained"
        , popup = leafpop::popupTable(
            constrained_spatial_temp
            , zcol = c(
              "Forest"
              , "IsTreatable"
            )
            , row.numbers = FALSE
            , feature.id = FALSE
          )
  )
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

```{r, eval=FALSE, include=FALSE}
fire_landscapes <- sf::st_read("../data/Wildfire_Crisis_Strategy_Landscapes/Wildfire_Crisis_Strategy_Landscapes_(Feature_Layer).shp") |> 
  sf::st_make_valid() |> 
  dplyr::mutate(area_ha = as.numeric(sf::st_area(geometry))/10000)
fire_landscapes$area_ha |> summary()
# map
mapview::mapview(fire_landscapes, zcol = "NAME", legend = F)
## split poly
# https://gis.stackexchange.com/questions/375345/dividing-polygon-into-parts-which-have-equal-area-using-r
split_poly_fn <- function(sf_poly, n_areas){
  # create random points
  points_rnd <- sf::st_sample(sf_poly, size = 10000)
  #k-means clustering
  points <- do.call(rbind, sf::st_geometry(points_rnd)) |> 
    dplyr::as_tibble() |>  
    setNames(c("lon","lat"))
  k_means <- kmeans(points, centers = n_areas)
  # create voronoi polygons
  voronoi_polys <- dismo::voronoi(k_means$centers, ext = sf_poly |> sf::as_Spatial())
  # clip to sf_poly
  crs(voronoi_polys) <- crs(sf_poly)
  voronoi_sf <- sf::st_as_sf(voronoi_polys)
  equal_areas <- sf::st_intersection(voronoi_sf, sf_poly)
  equal_areas$split_area_ha <- as.numeric(sf::st_area(equal_areas))/10000
  return(equal_areas)
}
# map function over all
fire_landscapes_split <- 1:nrow(fire_landscapes) |> 
  purrr::map(function(x){
    sf_temp <- fire_landscapes |> 
      dplyr::filter(dplyr::row_number()==x) |> 
      sf::st_geometry()
    n_areas_temp <- ceiling(
        (fire_landscapes |> 
          dplyr::filter(dplyr::row_number()==x) |> 
          sf::st_drop_geometry() |> 
          dplyr::pull(area_ha)
        )/600000
      )
    # split
    split_temp <- split_poly_fn(sf_poly = sf_temp, n_areas = max(2,n_areas_temp)) |> 
      dplyr::bind_cols(
        fire_landscapes |> 
          dplyr::filter(dplyr::row_number()==x) |> 
          sf::st_drop_geometry()
      )
    return(split_temp)
  }) |> 
  dplyr::bind_rows()
mapview::mapview(fire_landscapes_split, zcol = "NAME", legend = F)
sf::st_write(fire_landscapes_split
             , "../data/Wildfire_Crisis_Strategy_Landscapes/Wildfire_Crisis_Strategy_Landscapes_split.shp"
             , append = F
            )
sf::st_crs(fire_landscapes_split)
fire_landscapes_split$split_area_ha |> summary()
```


```{r, eval=FALSE, include=FALSE}
xxx1 <- sf::st_read("../data/xxx/xxx_vectors.shp") |> 
  dplyr::mutate(
      IsTreatable = factor(
        istreatabl
        , ordered = TRUE
        , levels = c(0,1)
        , labels = c("Constrained", "Treatable")
      )
    ) |> 
  dplyr::group_by(IsTreatable) |> 
  dplyr::summarise(
    geometry = sf::st_union(geometry)
  ) |> 
  dplyr::ungroup()

xxx2 <- sf::st_read("../data/xxx/xxxnoclip_vectors.shp") |> 
  dplyr::mutate(
      IsTreatable = factor(
        istreatabl
        , ordered = TRUE
        , levels = c(0,1)
        , labels = c("Constrained", "Treatable")
      )
    ) |> 
  dplyr::group_by(IsTreatable) |> 
  dplyr::summarise(
    geometry = sf::st_union(geometry)
  ) |> 
  dplyr::ungroup()

  
# basemap option
mapview::mapviewOptions(homebutton = FALSE, basemaps = c("Esri.WorldImagery"))
# map
mapview::mapview( xxx1
        , zcol = "IsTreatable"
        , col.regions = viridis::turbo(n=2,direction = -1)
        , alpha.regions = 0.6
        , lwd = 0
        , label = FALSE
        , legend = FALSE
        , layer.name = "xxx1"
        , popup = leafpop::popupTable(
            xxx1
            , zcol = c(
              "IsTreatable"
            )
            , row.numbers = FALSE
            , feature.id = FALSE
          )
  ) + mapview::mapview( xxx2
        , zcol = "IsTreatable"
        , col.regions = viridis::turbo(n=2,direction = -1)
        , alpha.regions = 0.6
        , lwd = 0
        , label = FALSE
        , legend = FALSE
        , layer.name = "xxx2"
        , popup = leafpop::popupTable(
            xxx2
            , zcol = c(
              "IsTreatable"
            )
            , row.numbers = FALSE
            , feature.id = FALSE
          )
  )

```

